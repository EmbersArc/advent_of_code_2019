fn get_input() -> Vec<i64> {
    vec![
        3,
        8,
        1005,
        8,
        332,
        1106,
        0,
        11,
        0,
        0,
        0,
        104,
        1,
        104,
        0,
        3,
        8,
        102,
        -1,
        8,
        10,
        101,
        1,
        10,
        10,
        4,
        10,
        108,
        1,
        8,
        10,
        4,
        10,
        101,
        0,
        8,
        28,
        3,
        8,
        102,
        -1,
        8,
        10,
        1001,
        10,
        1,
        10,
        4,
        10,
        1008,
        8,
        1,
        10,
        4,
        10,
        101,
        0,
        8,
        51,
        1,
        1103,
        5,
        10,
        1,
        1104,
        9,
        10,
        2,
        1003,
        0,
        10,
        1,
        5,
        16,
        10,
        3,
        8,
        102,
        -1,
        8,
        10,
        101,
        1,
        10,
        10,
        4,
        10,
        108,
        0,
        8,
        10,
        4,
        10,
        1001,
        8,
        0,
        88,
        1006,
        0,
        2,
        1006,
        0,
        62,
        2,
        8,
        2,
        10,
        3,
        8,
        1002,
        8,
        -1,
        10,
        101,
        1,
        10,
        10,
        4,
        10,
        1008,
        8,
        1,
        10,
        4,
        10,
        102,
        1,
        8,
        121,
        1006,
        0,
        91,
        1006,
        0,
        22,
        1006,
        0,
        23,
        1006,
        0,
        1,
        3,
        8,
        102,
        -1,
        8,
        10,
        1001,
        10,
        1,
        10,
        4,
        10,
        1008,
        8,
        1,
        10,
        4,
        10,
        101,
        0,
        8,
        155,
        1006,
        0,
        97,
        1,
        1004,
        2,
        10,
        2,
        1003,
        6,
        10,
        3,
        8,
        1002,
        8,
        -1,
        10,
        101,
        1,
        10,
        10,
        4,
        10,
        108,
        0,
        8,
        10,
        4,
        10,
        1002,
        8,
        1,
        187,
        1,
        104,
        15,
        10,
        2,
        107,
        9,
        10,
        1006,
        0,
        37,
        1006,
        0,
        39,
        3,
        8,
        1002,
        8,
        -1,
        10,
        1001,
        10,
        1,
        10,
        4,
        10,
        108,
        0,
        8,
        10,
        4,
        10,
        102,
        1,
        8,
        223,
        2,
        2,
        17,
        10,
        1,
        1102,
        5,
        10,
        3,
        8,
        1002,
        8,
        -1,
        10,
        101,
        1,
        10,
        10,
        4,
        10,
        108,
        0,
        8,
        10,
        4,
        10,
        1001,
        8,
        0,
        253,
        3,
        8,
        102,
        -1,
        8,
        10,
        1001,
        10,
        1,
        10,
        4,
        10,
        1008,
        8,
        1,
        10,
        4,
        10,
        1002,
        8,
        1,
        276,
        1006,
        0,
        84,
        3,
        8,
        102,
        -1,
        8,
        10,
        101,
        1,
        10,
        10,
        4,
        10,
        1008,
        8,
        0,
        10,
        4,
        10,
        1001,
        8,
        0,
        301,
        2,
        1009,
        9,
        10,
        1006,
        0,
        10,
        2,
        102,
        15,
        10,
        101,
        1,
        9,
        9,
        1007,
        9,
        997,
        10,
        1005,
        10,
        15,
        99,
        109,
        654,
        104,
        0,
        104,
        1,
        21102,
        1,
        936995738516,
        1,
        21101,
        0,
        349,
        0,
        1105,
        1,
        453,
        21102,
        1,
        825595015976,
        1,
        21102,
        1,
        360,
        0,
        1105,
        1,
        453,
        3,
        10,
        104,
        0,
        104,
        1,
        3,
        10,
        104,
        0,
        104,
        0,
        3,
        10,
        104,
        0,
        104,
        1,
        3,
        10,
        104,
        0,
        104,
        1,
        3,
        10,
        104,
        0,
        104,
        0,
        3,
        10,
        104,
        0,
        104,
        1,
        21102,
        46375541763,
        1,
        1,
        21101,
        0,
        407,
        0,
        1105,
        1,
        453,
        21102,
        1,
        179339005019,
        1,
        21101,
        0,
        418,
        0,
        1106,
        0,
        453,
        3,
        10,
        104,
        0,
        104,
        0,
        3,
        10,
        104,
        0,
        104,
        0,
        21102,
        825012036372,
        1,
        1,
        21102,
        441,
        1,
        0,
        1105,
        1,
        453,
        21101,
        988648461076,
        0,
        1,
        21101,
        452,
        0,
        0,
        1105,
        1,
        453,
        99,
        109,
        2,
        22102,
        1,
        -1,
        1,
        21102,
        40,
        1,
        2,
        21102,
        484,
        1,
        3,
        21101,
        0,
        474,
        0,
        1106,
        0,
        517,
        109,
        -2,
        2105,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        109,
        2,
        3,
        10,
        204,
        -1,
        1001,
        479,
        480,
        495,
        4,
        0,
        1001,
        479,
        1,
        479,
        108,
        4,
        479,
        10,
        1006,
        10,
        511,
        1102,
        1,
        0,
        479,
        109,
        -2,
        2105,
        1,
        0,
        0,
        109,
        4,
        2102,
        1,
        -1,
        516,
        1207,
        -3,
        0,
        10,
        1006,
        10,
        534,
        21101,
        0,
        0,
        -3,
        21202,
        -3,
        1,
        1,
        22101,
        0,
        -2,
        2,
        21102,
        1,
        1,
        3,
        21102,
        553,
        1,
        0,
        1106,
        0,
        558,
        109,
        -4,
        2106,
        0,
        0,
        109,
        5,
        1207,
        -3,
        1,
        10,
        1006,
        10,
        581,
        2207,
        -4,
        -2,
        10,
        1006,
        10,
        581,
        22102,
        1,
        -4,
        -4,
        1105,
        1,
        649,
        21202,
        -4,
        1,
        1,
        21201,
        -3,
        -1,
        2,
        21202,
        -2,
        2,
        3,
        21101,
        0,
        600,
        0,
        1105,
        1,
        558,
        21201,
        1,
        0,
        -4,
        21101,
        0,
        1,
        -1,
        2207,
        -4,
        -2,
        10,
        1006,
        10,
        619,
        21101,
        0,
        0,
        -1,
        22202,
        -2,
        -1,
        -2,
        2107,
        0,
        -3,
        10,
        1006,
        10,
        641,
        22102,
        1,
        -1,
        1,
        21102,
        1,
        641,
        0,
        106,
        0,
        516,
        21202,
        -2,
        -1,
        -2,
        22201,
        -4,
        -2,
        -4,
        109,
        -5,
        2105,
        1,
        0,
    ]
}

struct Program {
    initial_state: Vec<i64>,
    memory: Vec<i64>,
    i: usize,
    inputs: Vec<i64>,
    i_input: usize,
    rel_base: i64,
    is_done: bool,
}

impl Program {
    /** Returns digits in reversed order in vector of size 5: 123 -> [0,0,3,2,1] */
    fn get_digits(number: i64) -> Vec<i64> {
        let mut digits = vec![0; 5];
        let mut n = number;
        let mut i = 0;
        while n > 9 {
            digits[i] = n % 10;
            n = n / 10;
            i += 1;
        }
        digits[i] = n;

        digits
    }

    fn fetch_input(&mut self, mode: i64, parameter: i64) -> i64 {
        match mode {
            0 => self.memory[parameter as usize],
            1 => parameter,
            2 => self.memory[(parameter + self.rel_base) as usize],
            _ => panic!("Invalid parameter mode!"),
        }
    }
    fn fetch_address(&mut self, mode: i64, parameter: i64) -> usize {
        match mode {
            0 => parameter as usize,
            2 => (parameter + self.rel_base) as usize,
            _ => panic!("Invalid parameter mode!"),
        }
    }

    fn from(memory: &Vec<i64>) -> Program {
        let mut new_memory = memory.clone();
        // just *100 and hope for the best
        new_memory.resize(100 * new_memory.len(), 0);
        Program {
            initial_state: memory.clone(),
            memory: new_memory,
            i: 0,
            inputs: Vec::new(),
            i_input: 0,
            is_done: false,
            rel_base: 0,
        }
    }
    fn set_input(&mut self, input: &Vec<i64>) {
        self.inputs = input.clone();
        self.i_input = 0;
    }
    fn reset(&mut self) {
        self.memory = self.initial_state.clone();
        self.memory.resize(100 * self.memory.len(), 0);
        self.i_input = 0;
        self.is_done = false;
        self.inputs.clear();
        self.i = 0;
        self.rel_base = 0;
    }
    fn step(&mut self) -> i64 {
        loop {
            // parse instruction
            let digits = Program::get_digits(self.memory[self.i]);
            let opcode = 10 * digits[1] + digits[0];
            let mode_par1 = digits[2];
            let mode_par2 = digits[3];
            let mode_par3 = digits[4];

            if opcode == 99 {
                self.is_done = true;
                return -1;
            }

            // get parameters
            let mut par1 = 0;
            let mut par2 = 0;
            let mut par3 = 0;
            if self.memory.len() > self.i + 1 {
                par1 = self.memory[self.i + 1];
            }
            if self.memory.len() > self.i + 2 {
                par2 = self.memory[self.i + 2];
            }
            if self.memory.len() > self.i + 3 {
                par3 = self.memory[self.i + 3];
            }

            match opcode {
                1 | 2 | 7 | 8 => {
                    let input_1 = self.fetch_input(mode_par1, par1);
                    let input_2 = self.fetch_input(mode_par2, par2);
                    let input_3 = self.fetch_address(mode_par3, par3);

                    if opcode == 1 {
                        // add
                        self.memory[input_3] = input_1 + input_2;
                    } else if opcode == 2 {
                        // multiply
                        self.memory[input_3] = input_1 * input_2;
                    } else if opcode == 7 {
                        // less than
                        self.memory[input_3] = (input_1 < input_2) as i64;
                    } else if opcode == 8 {
                        // equals
                        self.memory[input_3] = (input_1 == input_2) as i64;
                    }

                    self.i += 4;
                }
                3 => {
                    // take input
                    let input_1 = self.fetch_address(mode_par1, par1);

                    if self.i_input >= self.inputs.len() {
                        panic!("No more inputs available!");
                    }
                    self.memory[input_1] = self.inputs[self.i_input];
                    self.i_input += 1;
                    self.i += 2;
                }
                4 => {
                    // output
                    let input_1 = self.fetch_input(mode_par1, par1);

                    self.i += 2;
                    return input_1;
                }
                5 | 6 => {
                    let input_1 = self.fetch_input(mode_par1, par1);
                    let input_2 = self.fetch_input(mode_par2, par2);

                    if opcode == 5 {
                        // jump if true
                        if input_1 != 0 {
                            self.i = input_2 as usize;
                        } else {
                            self.i += 3;
                        }
                    } else if opcode == 6 {
                        // jump if false
                        if input_1 == 0 {
                            self.i = input_2 as usize;
                        } else {
                            self.i += 3;
                        }
                    }
                }
                9 => {
                    // change relative base
                    let input_1 = self.fetch_input(mode_par1, par1);

                    self.rel_base += input_1;
                    self.i += 2;
                }
                _ => panic!("Encountered invalid opcode '{}'!", opcode),
            }
        }
    }
}

use std::collections::HashMap;

fn pt1() {
    let mut direction = 0; // up (0), left (1), down (2), right (3)
    let mut position = (0, 0);
    let mut painted_tiles = HashMap::new(); // (x,y): color

    let mut program = Program::from(&get_input());

    while !program.is_done {
        let current_color = match painted_tiles.get(&position) {
            Some(color) => *color,
            None => 0, // black
        };
        program.set_input(&vec![current_color]);
        let new_color = program.step();

        if program.is_done {
            break;
        }

        painted_tiles.insert(position, new_color);

        let turn_direction = program.step();

        match turn_direction {
            0 => direction = (direction + 3) % 4, // left turn
            1 => direction = (direction + 1) % 4, // right turn
            _ => panic!("Found invalid turn direction."),
        }

        match direction {
            0 => position.1 += 1,
            1 => position.0 -= 1,
            2 => position.1 -= 1,
            3 => position.0 += 1,
            _ => panic!("Found invalid direction."),
        }
    }
    println!("Solution Part 1: {}", painted_tiles.len());
}

fn pt2() {
    let mut direction = 0; // up (0), left (1), down (2), right (3)
    let mut position = (0, 0);
    let mut painted_tiles = HashMap::new(); // (x,y): color

    painted_tiles.insert(position, 1); // the single white tile

    let mut program = Program::from(&get_input());

    while !program.is_done {
        let current_color = match painted_tiles.get(&position) {
            Some(color) => *color,
            None => 0, // black
        };
        program.set_input(&vec![current_color]);
        let new_color = program.step();

        if program.is_done {
            break;
        }

        painted_tiles.insert(position, new_color);

        let turn_direction = program.step();

        match turn_direction {
            0 => direction = (direction + 3) % 4, // left turn
            1 => direction = (direction + 1) % 4, // right turn
            _ => panic!("Found invalid turn direction."),
        }

        match direction {
            0 => position.1 += 1,
            1 => position.0 -= 1,
            2 => position.1 -= 1,
            3 => position.0 += 1,
            _ => panic!("Found invalid direction."),
        }
    }

    let mut hull: Vec<Vec<char>> = Vec::new();

    let min_x: i32 = painted_tiles.keys().min_by_key(|pos| pos.0).unwrap().0;
    let min_y: i32 = painted_tiles.keys().min_by_key(|pos| pos.1).unwrap().1;
    let max_x: i32 = painted_tiles.keys().max_by_key(|pos| pos.0).unwrap().0;
    let max_y: i32 = painted_tiles.keys().max_by_key(|pos| pos.1).unwrap().1;

    let width = max_x - min_x;
    let height = max_y - min_y;

    hull.resize(height as usize + 1, vec![' '; width as usize + 1]);

    for (pos, color) in &painted_tiles {
        if *color == 1 {
            hull[(pos.1 - min_y) as usize][(pos.0 - min_x) as usize] = '#';
        }
    }

    println!("Solution Part 2:");

    for line in hull.iter().rev() {
        let line_string: String = if line.is_empty() {
            "".to_string()
        } else {
            line.into_iter().rev().collect()
        };
        println!("{}", line_string);
    }
}

fn main() {
    pt1();
    pt2();
}
